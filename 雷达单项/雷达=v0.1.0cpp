void radarAvoidance()
{
    // 1. 读取传感器数据
    leftDistance = readDistance(leftTrig, leftEcho);
    frontDistance = readDistance(frontTrig, frontEcho);
    rightDistance = readDistance(rightTrig, rightEcho);

    // 2. 输出传感器数据和当前状态
    Serial.print("[传感器数据] 左:");
    Serial.print(leftDistance);
    Serial.print("cm 前:");
    Serial.print(frontDistance);
    Serial.print("cm 右:");
    Serial.print(rightDistance);
    Serial.println("cm");

    // 3. 参数定义
    const float SIZE_CAR = 20.0;              // 车辆标准轴距(cm)
    const float TOO_CLOSE = SIZE_CAR * 0.5;   // 紧急停止距离(10cm)
    const float RIGHT_WALL = SIZE_CAR * 0.75; // 理想右侧距离(15cm)
    const float RIGHT_TURN = SIZE_CAR * 2;    // 右转阈值距离(40cm)

    const float CRUISE_SPEED = 140;              // 巡航速度
    const float TRIM_SPEED = CRUISE_SPEED * 0.5; // 微调/转向速度

    // 4. 状态变量
    static bool isFollowingWall = false;    // 跟墙状态标志
    static bool isTurning = false;          // 转向状态标志
    static unsigned long turnStartTime = 0; // 转向开始时间

    const unsigned long TURN_DURATION = 1000; // 转向持续时间(ms)
    const int BACK_FOR_TOO_CLOSE = 200;       // 紧急后退时间(ms)

    // 5. 决策逻辑
    // 5.1 紧急情况处理 - 前方障碍物过近
    if (frontDistance < TOO_CLOSE)
    {
        Serial.println("[决策] 紧急停止！前方障碍物过近，后退中...");
        moveBackward(TRIM_SPEED);
        delay(BACK_FOR_TOO_CLOSE);
        stopMotors();
        isTurning = false;
        isFollowingWall = false;
        return;
    }

    // 5.2 转向中处理
    if (isTurning)
    {
        if (millis() - turnStartTime < TURN_DURATION)
        {
            Serial.println("[决策] 转向中...");
            return; // 保持转向状态
        }
        else
        {
            isTurning = false;
            stopMotors();
            isFollowingWall = (rightDistance < RIGHT_WALL);
            Serial.println("[决策] 转向完成，重新检测墙壁");
        }
    }

    // 5.3 靠右行驶主逻辑
    if (rightDistance < RIGHT_WALL * 1.2)
    {
        isFollowingWall = true;

        if (rightDistance < RIGHT_WALL * 0.8)
        {
            Serial.println("[决策] 太靠近右侧，向左微调");
            motorControlState(CRUISE_SPEED * 0.8, CRUISE_SPEED);
            delay(50);
        }
        else if (rightDistance > RIGHT_WALL)
        {
            Serial.println("[决策] 离右侧太远，向右微调");
            motorControlState(CRUISE_SPEED, CRUISE_SPEED * 0.8);
            delay(50);
        }
        else
        {
            Serial.println("[决策] 保持理想距离，直行");
            moveForward(CRUISE_SPEED);
        }
        return;
    }

    // 5.4 无右侧墙壁时，主动寻找右侧墙壁
    if (!isFollowingWall)
    {
        Serial.println("[决策] 寻找右侧墙壁，小角度右转");
        motorControlState(CRUISE_SPEED, CRUISE_SPEED * 0.5);
        delay(100);
        return;
    }

    // 5.5 前方障碍物处理（非跟墙状态）
    if (frontDistance < SIZE_CAR)
    {
        if (rightDistance > RIGHT_TURN)
        {
            Serial.println("[决策] 前方障碍物，优先右转");
            turnRight(TRIM_SPEED);
        }
        else
        {
            Serial.println("[决策] 前方障碍物，无法右转，执行左转");
            turnLeft(TRIM_SPEED);
        }
        isTurning = true;
        turnStartTime = millis();
        return;
    }

    // 5.6 默认行为 - 前进（稍偏右）
    Serial.println("[决策] 默认行为，前进（稍偏右）");
    motorControlState(CRUISE_SPEED, CRUISE_SPEED * 0.9);
}